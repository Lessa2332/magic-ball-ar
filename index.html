<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Christmas Gloves AR Try-On</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéÑ</text></svg>">
  <style>
    /* ... –≤–∞—à —ñ—Å–Ω—É—é—á–∏–π CSS –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è –±–µ–∑ –∑–º—ñ–Ω ... */
  </style>
</head>
<body>
  <!-- ... –≤–∞—à —ñ—Å–Ω—É—é—á–∏–π HTML –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è –±–µ–∑ –∑–º—ñ–Ω ... -->

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

    // ========== –ö–û–ù–§–Ü–ì–£–†–ê–¶–Ü–Ø ==========
    const CONFIG = {
      SCALE: {
        BASE_SCALE: 400,
        DISTANCE_MULTIPLIER: 0.8,
        MIN_SCALE: 200,
        MAX_SCALE: 600
      },
      HANDS: {
        MAX_HANDS: 2,
        DETECTION_THRESHOLD: 10
      },
      PERFORMANCE: {
        DETECTION_THROTTLE_MS: 50,
        MAX_SPARKLES: 150,
        SPARKLE_SPAWN_RATE: 0.08
      },
      AUDIO: {
        VOLUME: 0.4,
        CLICK_VOLUME: 0.5
      },
      DESIGNS: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"],
      DEBUG: {
        ENABLED: false
      }
    };

    // ========== TRANSLATIONS ==========
    const TRANSLATIONS = {
      en: {
        title: "Christmas Gloves AR Try-On",
        loading: "Loading Christmas AR Experience...",
        cameraPrompt: "Please allow camera access",
        retry: "Retry",
        handNotDetected: "Show your hand(s)",
        errorCamera: "Camera access denied. Try Chrome or Safari.",
        errorGeneral: "AR failed to load. Refresh page."
      },
      uk: {
        title: "–†—ñ–∑–¥–≤—è–Ω–∏–π AR-–ø—Ä–∏–º—ñ—Ä—è–ª—å–Ω–∏–∫ —Ä—É–∫–∞–≤–∏—á–æ–∫",
        loading: "–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ä—ñ–∑–¥–≤—è–Ω–æ–≥–æ AR...",
        cameraPrompt: "–ë—É–¥—å –ª–∞—Å–∫–∞, –¥–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏",
        retry: "–ü–æ–≤—Ç–æ—Ä–∏—Ç–∏",
        handNotDetected: "–ü–æ–∫–∞–∂—ñ—Ç—å —Ä—É–∫—É(—Ä—É–∫–∏)",
        errorCamera: "–î–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏ –∑–∞–±–æ—Ä–æ–Ω–µ–Ω–æ. –°–ø—Ä–æ–±—É–π—Ç–µ Chrome –∞–±–æ Safari.",
        errorGeneral: "AR –Ω–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏. –û–Ω–æ–≤—ñ—Ç—å —Å—Ç–æ—Ä—ñ–Ω–∫—É."
      }
    };

    // ========== SPARKLE PARTICLE ==========
    class SparkleParticle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 0.5;
        this.vy = Math.random() * 0.5 + 0.2;
        this.size = Math.random() * 2 + 1;
        this.life = 1.0;
        this.brightness = Math.random() * 0.5 + 0.5;
      }
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.02;
        this.vx *= 0.98;
        this.life -= 0.005;
       
        if (this.y > window.innerHeight) this.life = 0;
        if (this.x < 0 || this.x > window.innerWidth) this.life = 0;
      }
      draw(ctx) {
        if (this.life <= 0) return;
       
        ctx.save();
        ctx.globalAlpha = this.life * 0.8 * this.brightness;
        ctx.fillStyle = `hsl(${Math.random() * 60 + 60}, 100%, 80%)`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // ========== DEBUG MANAGER ==========
    class DebugManager {
      constructor() {
        this.enabled = CONFIG.DEBUG.ENABLED;
        this.elements = {
          debugInfo: document.getElementById('debugInfo')
        };
      }
      toggle() {
        this.enabled = !this.enabled;
        this.elements.debugInfo.style.display = this.enabled ? 'block' : 'none';
        return this.enabled;
      }
      updateInfo(info) {
        if (!this.enabled) return;
        this.elements.debugInfo.innerHTML = info;
      }
    }

    // ========== SERVICES ==========
    class AudioService {
      constructor() {
        this.click = new Audio('audio/click.mp3');
        this.click.volume = CONFIG.AUDIO.CLICK_VOLUME;
      }
      playClick() {
        this.click.currentTime = 0;
        this.click.play().catch(() => {});
      }
    }

    class HandDetectionService {
      constructor() {
        this.handLandmarker = null;
        this.isInitialized = false;
        this.lastDetectionTime = 0;
      }
      async initialize() {
        try {
          const vision = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
          );
         
          this.handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: {
              modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
              delegate: "GPU"
            },
            runningMode: "VIDEO",
            numHands: CONFIG.HANDS.MAX_HANDS
          });
         
          this.isInitialized = true;
          return true;
        } catch (error) {
          console.error('Hand detection initialization failed:', error);
          throw new Error('HAND_DETECTION_INIT_FAILED');
        }
      }
      detectHands(videoElement) {
        if (!this.isInitialized || videoElement.readyState < 2) {
          return null;
        }
        const now = performance.now();
        if (now - this.lastDetectionTime < CONFIG.PERFORMANCE.DETECTION_THROTTLE_MS) {
          return null;
        }
        this.lastDetectionTime = now;
       
        try {
          return this.handLandmarker.detectForVideo(videoElement, now);
        } catch (error) {
          console.error('Hand detection error:', error);
          return null;
        }
      }
      cleanup() {
        if (this.handLandmarker) {
          this.handLandmarker.close();
        }
        this.isInitialized = false;
      }
    }

    // ========== –û–ù–û–í–õ–ï–ù–ò–ô RENDERER –ó –ï–§–ï–ö–¢–û–ú "–ü–ï–†–ï–í–ï–†–¢–ê–ù–ù–Ø" ==========
    class GloveRenderer {
      constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.palmGloves = [];
        this.gloveTextures = new Map();
      }
      
      initialize(canvasElement) {
        this.scene = new THREE.Scene();
       
        this.camera = new THREE.OrthographicCamera(
          -window.innerWidth / 2,
          window.innerWidth / 2,
          window.innerHeight / 2,
          -window.innerHeight / 2,
          0.1,
          1000
        );
        this.camera.position.z = 10;
       
        this.renderer = new THREE.WebGLRenderer({
          canvas: canvasElement,
          alpha: true,
          antialias: true,
          powerPreference: "high-performance"
        });
       
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.createGloves();
      }
      
      createGloves() {
        const material = new THREE.MeshBasicMaterial({
          transparent: true,
          side: THREE.DoubleSide,
          depthTest: false
        });
        for (let i = 0; i < CONFIG.HANDS.MAX_HANDS; i++) {
          const geometry = new THREE.PlaneGeometry(1, 1);
          const glove = new THREE.Mesh(geometry, material.clone());
          glove.visible = false;
          this.scene.add(glove);
          this.palmGloves.push(glove);
        }
      }
      
      async loadTextures() {
        const loadPromises = CONFIG.DESIGNS.map(name =>
          new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.src = `gloves/winter/${name}.png`;
           
            img.onload = () => {
              const texture = new THREE.TextureLoader().load(`gloves/winter/${name}.png`);
              texture.minFilter = THREE.LinearFilter;
              texture.magFilter = THREE.LinearFilter;
              this.gloveTextures.set(name, texture);
              resolve();
            };
           
            img.onerror = () => {
              console.warn(`Failed to load design ${name}, using fallback`);
              this.createFallbackTexture(name);
              resolve();
            };
          })
        );
        await Promise.all(loadPromises);
      }
      
      createFallbackTexture(name) {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
       
        ctx.fillStyle = '#1a2980';
        ctx.fillRect(0, 0, 512, 512);
        ctx.fillStyle = 'white';
        ctx.font = '32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`Design ${name}`, 256, 266);
       
        this.gloveTextures.set(name, new THREE.CanvasTexture(canvas));
      }

      // –î–ò–ù–ê–ú–Ü–ß–ù–ï –ú–ê–°–®–¢–ê–ë–£–í–ê–ù–ù–Ø
      calculateHandScale(landmarks) {
        const wrist = landmarks[0];
        const middleFingerTip = landmarks[12];
        
        const distance = Math.sqrt(
          Math.pow(wrist.x - middleFingerTip.x, 2) + 
          Math.pow(wrist.y - middleFingerTip.y, 2)
        );
        
        let scale = CONFIG.SCALE.BASE_SCALE * distance * CONFIG.SCALE.DISTANCE_MULTIPLIER;
        scale = Math.max(CONFIG.SCALE.MIN_SCALE, Math.min(CONFIG.SCALE.MAX_SCALE, scale));
        
        return scale;
      }

      // –í–ò–ó–ù–ê–ß–ï–ù–ù–Ø –°–¢–û–†–û–ù–ò –î–û–õ–û–ù–Ü (–∑–±–µ—Ä–µ–∂–µ–Ω–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω—É –ª–æ–≥—ñ–∫—É)
      determinePalmSide(landmarks, handIndex) {
        const thumbBase = landmarks[1];
        const pinkyBase = landmarks[17];
        const palmDirection = thumbBase.x - pinkyBase.x;

        // –û–†–ò–ì–Ü–ù–ê–õ–¨–ù–ê –õ–û–ì–Ü–ö–ê –ó –ï–§–ï–ö–¢–û–ú "–ü–ï–†–ï–í–ï–†–¢–ê–ù–ù–Ø"
        if (handIndex === 1) {
          // –ü—Ä–∞–≤–∞ —Ä—É–∫–∞
          return palmDirection > 0 ? 'palm' : 'back';
        } else {
          // –õ—ñ–≤–∞ —Ä—É–∫–∞  
          return palmDirection < 0 ? 'palm' : 'back';
        }
      }

      updateGlove(handIndex, handData, designName) {
        const glove = this.palmGloves[handIndex];
        if (!glove || !handData) {
          if (glove) glove.visible = false;
          return null;
        }

        const { landmarks, wrist } = handData;
        
        // –†–û–ó–†–ê–•–£–ù–û–ö –ú–ê–°–®–¢–ê–ë–£
        const scale = this.calculateHandScale(landmarks);
        
        // –ü–û–ó–ò–¶–Ü–Ø –ö–Ü–ù–ß–ò–ö–ê –°–ï–†–ï–î–ù–¨–û–ì–û –ü–ê–õ–¨–¶–Ø (—è–∫ —É –æ—Ä–∏–≥—ñ–Ω–∞–ª—ñ)
        const middleFingerTip = landmarks[12];
        const centerX = middleFingerTip.x * window.innerWidth;
        const centerY = (1 - middleFingerTip.y) * window.innerHeight;
        
        // Rotation - –≤—ñ–¥ –∑–∞–ø'—è—Å—Ç—è –¥–æ –∫—ñ–Ω—á–∏–∫–∞ —Å–µ—Ä–µ–¥–Ω—å–æ–≥–æ –ø–∞–ª—å—Ü—è
        const angle = Math.atan2(
          middleFingerTip.y - wrist.y,
          middleFingerTip.x - wrist.x
        );
        
        const glovePosition = {
          x: centerX - window.innerWidth / 2,
          y: centerY - window.innerHeight / 2
        };
        
        glove.position.set(glovePosition.x, glovePosition.y, 0);
        
        // –ö–û–†–ï–ö–¶–Ü–Ø –ü–û–ó–ò–¶–Ü–á - —Ä—É–∫–∞–≤–∏—Ü—è –Ω–∞ –∫—ñ–Ω—á–∏–∫—É –ø–∞–ª—å—Ü—è
        const offsetDistance = scale * 0.4;
        glove.position.x -= Math.cos(angle) * offsetDistance;
        glove.position.y += Math.sin(angle) * offsetDistance;

        // –í–ò–ó–ù–ê–ß–ï–ù–ù–Ø –û–†–Ü–Ñ–ù–¢–ê–¶–Ü–á –î–û–õ–û–ù–Ü (–û–†–ò–ì–Ü–ù–ê–õ–¨–ù–ê –õ–û–ì–Ü–ö–ê –ó –ï–§–ï–ö–¢–û–ú)
        const palmSide = this.determinePalmSide(landmarks, handIndex);

        // –Ü–ù–¢–ï–õ–ï–ö–¢–£–ê–õ–¨–ù–ï –î–ó–ï–†–ö–ê–õ–ï–ù–ù–Ø - –ó–ë–ï–†–ï–ñ–ï–ù–û –ï–§–ï–ö–¢ "–ü–ï–†–ï–í–ï–†–¢–ê–ù–ù–Ø"
        if (handIndex === 1) {
          // –ü—Ä–∞–≤–∞ —Ä—É–∫–∞
          if (palmSide === 'palm') {
            // –î–æ–ª–æ–Ω—è –¥–æ –∫–∞–º–µ—Ä–∏ - –Ω–µ –¥–∑–µ—Ä–∫–∞–ª–∏–º–æ
            glove.scale.set(scale, -scale, 1);
          } else {
            // –ó–æ–≤–Ω—ñ—à–Ω—è —Å—Ç–æ—Ä–æ–Ω–∞ –¥–æ –∫–∞–º–µ—Ä–∏ - –¥–∑–µ—Ä–∫–∞–ª–∏–º–æ
            glove.scale.set(-scale, -scale, 1);
          }
        } else {
          // –õ—ñ–≤–∞ —Ä—É–∫–∞
          if (palmSide === 'palm') {
            // –î–æ–ª–æ–Ω—è –¥–æ –∫–∞–º–µ—Ä–∏ - –Ω–µ –¥–∑–µ—Ä–∫–∞–ª–∏–º–æ
            glove.scale.set(scale, -scale, 1);
          } else {
            // –ó–æ–≤–Ω—ñ—à–Ω—è —Å—Ç–æ—Ä–æ–Ω–∞ –¥–æ –∫–∞–º–µ—Ä–∏ - –¥–∑–µ—Ä–∫–∞–ª–∏–º–æ
            glove.scale.set(-scale, -scale, 1);
          }
        }
 
        // Vertical rotation
        glove.rotation.z = angle - Math.PI / 2;
        
        // Texture
        const texture = this.gloveTextures.get(designName);
        if (texture) {
          glove.material.map = texture;
          glove.material.needsUpdate = true;
        }
        
        glove.visible = true;
        
        return {
          position: { x: glove.position.x, y: glove.position.y },
          scale: scale,
          angle: angle,
          screenPosition: { x: centerX, y: centerY },
          palmSide: palmSide
        };
      }
      
      resize() {
        if (!this.camera || !this.renderer) return;
       
        this.camera.left = -window.innerWidth / 2;
        this.camera.right = window.innerWidth / 2;
        this.camera.top = window.innerHeight / 2;
        this.camera.bottom = -window.innerHeight / 2;
        this.camera.updateProjectionMatrix();
       
        this.renderer.setSize(window.innerWidth, window.innerHeight);
      }
      
      render() {
        if (this.scene && this.camera) {
          this.renderer.render(this.scene, this.camera);
        }
      }
      
      cleanup() {
        this.palmGloves.forEach(glove => {
          glove.geometry.dispose();
          glove.material.dispose();
        });
        this.gloveTextures.forEach(texture => texture.dispose());
        if (this.renderer) {
          this.renderer.dispose();
        }
      }
    }

    // ========== MAIN APPLICATION ==========
    class GloveARApplication {
      constructor() {
        this.state = {
          currentLang: 'en',
          currentDesign: "1",
          isMuted: false,
          handNotDetectedCount: 0,
          animationFrameId: null,
          isAudioUnlocked: false,
          hands: [],
          isInitialized: false
        };
       
        this.audioService = new AudioService();
        this.handDetection = new HandDetectionService();
        this.gloveRenderer = new GloveRenderer();
        this.debugManager = new DebugManager();
        this.sparkles = [];
       
        this.elements = {
          video: document.getElementById("video"),
          canvas: document.getElementById("canvas"),
          confettiCanvas: document.getElementById("confettiCanvas"),
          loading: document.getElementById("loading"),
          loadingText: document.getElementById("loadingText"),
          langBtn: document.getElementById("langBtn"),
          soundBtn: document.getElementById("soundBtn"),
          debugBtn: document.getElementById("debugBtn"),
          designPicker: document.getElementById("designPicker"),
          handIndicator: document.getElementById("handIndicator")
        };
        this.confettiCtx = this.elements.confettiCanvas.getContext("2d");
        this.bindEvents();
        this.resizeCanvases();
      }
      
      async initialize() {
        try {
          await this.setupCamera();
          this.gloveRenderer.initialize(this.elements.canvas);
          await this.handDetection.initialize();
          await this.gloveRenderer.loadTextures();
          this.buildDesignUI();
          this.updateUI();
          this.hideLoading();
          this.startRenderLoop();
          this.state.isInitialized = true;
        } catch (error) {
          this.handleError(error);
        }
      }
      
      bindEvents() {
        this.elements.langBtn.addEventListener('click', () => this.toggleLanguage());
        this.elements.soundBtn.addEventListener('click', () => this.toggleSound());
        this.elements.debugBtn.addEventListener('click', () => this.toggleDebug());
       
        window.addEventListener('resize', () => {
          this.resizeCanvases();
          if (this.state.isInitialized) {
            this.gloveRenderer.resize();
          }
        });
        window.addEventListener('beforeunload', () => this.cleanup());
      }
      
      toggleDebug() {
        const isEnabled = this.debugManager.toggle();
        this.elements.debugBtn.style.background = isEnabled ? '#00ff00' : '#ff4444';
        this.elements.debugBtn.textContent = isEnabled ? '‚úÖ' : 'üêõ';
      }
      
      async setupCamera() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: "environment",
              width: { ideal: 1280 },
              height: { ideal: 720 }
            }
          });
         
          this.elements.video.srcObject = stream;
         
          await new Promise((resolve) => {
            this.elements.video.onloadedmetadata = () => {
              this.elements.video.play().then(resolve);
            };
            setTimeout(resolve, 1000);
          });
         
        } catch (error) {
          console.error('Camera setup failed:', error);
          throw new Error('CAMERA_ERROR');
        }
      }
      
      toggleSound() {
        this.state.isMuted = !this.state.isMuted;
        this.elements.soundBtn.textContent = this.state.isMuted ? 'üîá' : 'üîä';
        this.audioService.playClick();
      }
      
      toggleLanguage() {
        this.state.currentLang = this.state.currentLang === 'en' ? 'uk' : 'en';
        this.elements.langBtn.textContent = this.state.currentLang === 'en' ? 'UK' : 'EN';
        this.updateUI();
        this.audioService.playClick();
      }
      
      buildDesignUI() {
        this.elements.designPicker.innerHTML = '';
       
        CONFIG.DESIGNS.forEach(name => {
          const btn = document.createElement('img');
          btn.src = `gloves/winter/${name}.png`;
          btn.className = `design-btn ${name === this.state.currentDesign ? 'selected' : ''}`;
          btn.alt = `Design ${name}`;
         
          btn.addEventListener('click', () => {
            this.state.currentDesign = name;
            document.querySelectorAll('.design-btn').forEach(b =>
              b.classList.toggle('selected', b === btn)
            );
            this.audioService.playClick();
            this.triggerSparkleExplosion();
          });
         
          this.elements.designPicker.appendChild(btn);
        });
      }
      
      triggerSparkleExplosion() {
        for (let i = 0; i < 20; i++) {
          const rect = this.elements.designPicker.getBoundingClientRect();
          const x = rect.left + Math.random() * rect.width;
          const y = rect.top + Math.random() * rect.height;
          this.sparkles.push(new SparkleParticle(x, y));
        }
      }
      
      startRenderLoop() {
        const render = () => {
          this.detectAndUpdateHands();
          this.updateSparkles();
          this.renderFrame();
          this.state.animationFrameId = requestAnimationFrame(render);
        };
        render();
      }
      
      detectAndUpdateHands() {
        const predictions = this.handDetection.detectHands(this.elements.video);
       
        if (predictions?.landmarks?.length > 0) {
          this.state.handNotDetectedCount = 0;
          this.elements.handIndicator.classList.remove('show');
          this.state.hands = predictions.landmarks.map((landmarks, i) => ({
            landmarks,
            wrist: landmarks[0]
          }));
        } else {
          this.state.handNotDetectedCount++;
          if (this.state.handNotDetectedCount > CONFIG.HANDS.DETECTION_THRESHOLD) {
            this.elements.handIndicator.classList.add('show');
            this.hideAllGloves();
          }
        }
      }
      
      hideAllGloves() {
        this.gloveRenderer.palmGloves.forEach(glove => {
          glove.visible = false;
        });
      }
      
      updateSparkles() {
        if (Math.random() < CONFIG.PERFORMANCE.SPARKLE_SPAWN_RATE) {
          this.sparkles.push(new SparkleParticle(
            Math.random() * window.innerWidth,
            -10
          ));
        }
        
        this.sparkles = this.sparkles.filter(p => {
          p.update();
          return p.life > 0;
        });
       
        while (this.sparkles.length > CONFIG.PERFORMANCE.MAX_SPARKLES) {
          this.sparkles.shift();
        }
       
        this.confettiCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
        this.sparkles.forEach(p => p.draw(this.confettiCtx));
      }
      
      renderFrame() {
        let debugInfo = `Hands: ${this.state.hands.length}<br>`;
        debugInfo += `Design: ${this.state.currentDesign}<br>`;
        
        for (let i = 0; i < this.state.hands.length; i++) {
          const hand = this.state.hands[i];
          const gloveData = this.gloveRenderer.updateGlove(
            i,
            hand,
            this.state.currentDesign
          );
          if (gloveData && this.debugManager.enabled) {
            debugInfo += `Hand ${i}:<br>`;
            debugInfo += `- Pos: (${gloveData.screenPosition.x.toFixed(1)}, ${gloveData.screenPosition.y.toFixed(1)})<br>`;
            debugInfo += `- Scale: ${gloveData.scale.toFixed(1)}<br>`;
            debugInfo += `- Angle: ${(gloveData.angle * 180 / Math.PI).toFixed(1)}¬∞<br>`;
            debugInfo += `- Palm Side: ${gloveData.palmSide}<br><br>`;
          }
        }
        this.debugManager.updateInfo(debugInfo);
        this.gloveRenderer.render();
      }
      
      resizeCanvases() {
        this.elements.confettiCanvas.width = window.innerWidth;
        this.elements.confettiCanvas.height = window.innerHeight;
      }
      
      updateUI() {
        const t = TRANSLATIONS[this.state.currentLang];
        document.title = t.title;
        this.elements.loadingText.textContent = t.loading;
        document.querySelector('#loading p').textContent = t.cameraPrompt;
        this.elements.handIndicator.innerHTML =
          `<span>üëê</span><span>${t.handNotDetected}</span>`;
      }
      
      hideLoading() {
        this.elements.loading.style.display = 'none';
        this.elements.video.style.display = 'block';
        this.elements.canvas.style.display = 'block';
      }
      
      handleError(error) {
        console.error('Application error:', error);
        const t = TRANSLATIONS[this.state.currentLang];
       
        let message = error.message === 'CAMERA_ERROR' ?
          t.errorCamera : t.errorGeneral;
         
        this.elements.loading.innerHTML = `
          <div style="color: #ff4757; font-size: 24px; margin-bottom: 20px;">Error</div>
          <div style="color: white; font-size: 18px; margin-bottom: 20px; line-height: 1.4;">${message}</div>
          <button id="errorRetry" style="
            padding: 12px 24px;
            background: #ffd700;
            border: none;
            border-radius: 25px;
            color: #1a2980;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
          ">${t.retry}</button>
        `;
       
        this.elements.loading.style.display = 'flex';
        document.getElementById('errorRetry').onclick = () => location.reload();
      }
      
      cleanup() {
        if (this.state.animationFrameId) {
          cancelAnimationFrame(this.state.animationFrameId);
        }
        if (this.elements.video.srcObject) {
          this.elements.video.srcObject.getTracks().forEach(track => track.stop());
        }
        this.handDetection.cleanup();
        this.gloveRenderer.cleanup();
      }
    }

    // ========== INITIALIZATION ==========
    window.addEventListener('DOMContentLoaded', () => {
      new GloveARApplication().initialize();
    });
  </script>
</body>
</html>
